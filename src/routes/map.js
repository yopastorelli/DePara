/**
 * Rotas de Mapeamento de Dados para DePara
 * 
 * @author yopastorelli
 * @version 1.0.0
 */

const express = require('express');
const router = express.Router();
const logger = require('../utils/logger');

/**
 * Mapear campos de dados
 * POST /api/map
 */
router.post('/', (req, res) => {
  const startTime = Date.now();
  
  try {
    const { sourceFields, targetFields, mapping, data, options = {} } = req.body;

    // Validação dos parâmetros obrigatórios
    if (!sourceFields || !targetFields || !mapping) {
      return res.status(400).json({
        error: {
          message: 'Parâmetros obrigatórios ausentes',
          details: 'sourceFields, targetFields e mapping são obrigatórios',
          required: ['sourceFields', 'targetFields', 'mapping']
        }
      });
    }

    // Validar que sourceFields e targetFields são arrays
    if (!Array.isArray(sourceFields) || !Array.isArray(targetFields)) {
      return res.status(400).json({
        error: {
          message: 'Parâmetros inválidos',
          details: 'sourceFields e targetFields devem ser arrays',
          received: {
            sourceFields: typeof sourceFields,
            targetFields: typeof targetFields
          }
        }
      });
    }

    // Validar que mapping é um objeto
    if (typeof mapping !== 'object' || mapping === null) {
      return res.status(400).json({
        error: {
          message: 'Parâmetro mapping inválido',
          details: 'mapping deve ser um objeto',
          received: typeof mapping
        }
      });
    }

    logger.startOperation('Data Mapping', {
      sourceFieldsCount: sourceFields.length,
      targetFieldsCount: targetFields.length,
      mappingKeys: Object.keys(mapping).length,
      hasData: !!data
    });

    // Aplicar mapeamento
    let mappedData;
    let mappingDetails;

    try {
      if (data) {
        mappedData = applyMapping(data, sourceFields, targetFields, mapping, options);
      } else {
        // Retornar apenas o esquema de mapeamento
        mappedData = {
          sourceFields,
          targetFields,
          mapping,
          schema: generateMappingSchema(sourceFields, targetFields, mapping)
        };
      }

      mappingDetails = {
        sourceFieldsCount: sourceFields.length,
        targetFieldsCount: targetFields.length,
        mappingRules: Object.keys(mapping).length,
        processingTime: Date.now() - startTime,
        options
      };

      logger.endOperation('Data Mapping', Date.now() - startTime, mappingDetails);

      res.status(200).json({
        success: true,
        data: mappedData,
        mapping: mappingDetails,
        timestamp: new Date().toISOString()
      });

    } catch (mappingError) {
      logger.operationError('Data Mapping', mappingError, {
        sourceFields,
        targetFields,
        mappingKeys: Object.keys(mapping)
      });

      res.status(500).json({
        error: {
          message: 'Erro durante o mapeamento',
          details: mappingError.message,
          sourceFields,
          targetFields
        }
      });
    }

  } catch (error) {
    logger.operationError('Data Mapping Request', error);
    res.status(500).json({
      error: {
        message: 'Erro interno do servidor',
        details: error.message
      }
    });
  }
});

/**
 * Gerar esquema de mapeamento automático
 * POST /api/map/auto
 */
router.post('/auto', (req, res) => {
  const startTime = Date.now();
  
  try {
    const { sourceFields, targetFields, sampleData, strategy = 'similarity' } = req.body;

    if (!sourceFields || !targetFields) {
      return res.status(400).json({
        error: {
          message: 'Parâmetros obrigatórios ausentes',
          details: 'sourceFields e targetFields são obrigatórios',
          required: ['sourceFields', 'targetFields']
        }
      });
    }

    logger.startOperation('Auto Mapping', {
      sourceFieldsCount: sourceFields.length,
      targetFieldsCount: targetFields.length,
      strategy
    });

    // Gerar mapeamento automático
    const autoMapping = generateAutoMapping(sourceFields, targetFields, sampleData, strategy);
    
    const mappingDetails = {
      sourceFieldsCount: sourceFields.length,
      targetFieldsCount: targetFields.length,
      autoGeneratedRules: Object.keys(autoMapping).length,
      strategy,
      processingTime: Date.now() - startTime
    };

    logger.endOperation('Auto Mapping', Date.now() - startTime, mappingDetails);

    res.status(200).json({
      success: true,
      mapping: autoMapping,
      details: mappingDetails,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.operationError('Auto Mapping', error);
    res.status(500).json({
      error: {
        message: 'Erro ao gerar mapeamento automático',
        details: error.message
      }
    });
  }
});

/**
 * Validar esquema de mapeamento
 * POST /api/map/validate
 */
router.post('/validate', (req, res) => {
  const startTime = Date.now();
  
  try {
    const { sourceFields, targetFields, mapping, data } = req.body;

    if (!sourceFields || !targetFields || !mapping) {
      return res.status(400).json({
        error: {
          message: 'Parâmetros obrigatórios ausentes',
          details: 'sourceFields, targetFields e mapping são obrigatórios'
        }
      });
    }

    logger.startOperation('Mapping Validation', {
      sourceFieldsCount: sourceFields.length,
      targetFieldsCount: targetFields.length,
      mappingKeys: Object.keys(mapping).length
    });

    // Validar mapeamento
    const validation = validateMapping(sourceFields, targetFields, mapping, data);
    
    const validationDetails = {
      isValid: validation.isValid,
      errors: validation.errors,
      warnings: validation.warnings,
      processingTime: Date.now() - startTime
    };

    logger.endOperation('Mapping Validation', Date.now() - startTime, validationDetails);

    res.status(200).json({
      success: true,
      validation: validationDetails,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.operationError('Mapping Validation', error);
    res.status(500).json({
      error: {
        message: 'Erro ao validar mapeamento',
        details: error.message
      }
    });
  }
});

// Funções auxiliares

function applyMapping(data, sourceFields, targetFields, mapping, options) {
  if (Array.isArray(data)) {
    return data.map(item => mapSingleRecord(item, sourceFields, targetFields, mapping, options));
  } else if (typeof data === 'object' && data !== null) {
    return mapSingleRecord(data, sourceFields, targetFields, mapping, options);
  } else {
    throw new Error('Dados devem ser um objeto ou array de objetos');
  }
}

function mapSingleRecord(record, sourceFields, targetFields, mapping, options) {
  const mappedRecord = {};
  
  // Aplicar mapeamento
  for (const [sourceField, targetField] of Object.entries(mapping)) {
    if (record.hasOwnProperty(sourceField)) {
      mappedRecord[targetField] = record[sourceField];
    } else if (options.strict) {
      throw new Error(`Campo de origem '${sourceField}' não encontrado nos dados`);
    }
  }

  // Preencher campos de destino não mapeados com valores padrão
  if (options.fillUnmapped) {
    for (const targetField of targetFields) {
      if (!mappedRecord.hasOwnProperty(targetField)) {
        mappedRecord[targetField] = options.defaultValue || null;
      }
    }
  }

  return mappedRecord;
}

function generateMappingSchema(sourceFields, targetFields, mapping) {
  return {
    source: sourceFields,
    target: targetFields,
    rules: mapping,
    coverage: {
      sourceCovered: Object.keys(mapping).length,
      sourceTotal: sourceFields.length,
      targetCovered: new Set(Object.values(mapping)).size,
      targetTotal: targetFields.length
    }
  };
}

function generateAutoMapping(sourceFields, targetFields, sampleData, strategy) {
  const mapping = {};
  
  if (strategy === 'similarity') {
    // Mapeamento baseado em similaridade de nomes
    for (const sourceField of sourceFields) {
      const bestMatch = findBestMatch(sourceField, targetFields);
      if (bestMatch) {
        mapping[sourceField] = bestMatch;
      }
    }
  } else if (strategy === 'position') {
    // Mapeamento baseado na posição (assumindo ordem similar)
    const minLength = Math.min(sourceFields.length, targetFields.length);
    for (let i = 0; i < minLength; i++) {
      mapping[sourceFields[i]] = targetFields[i];
    }
  }

  return mapping;
}

function findBestMatch(sourceField, targetFields) {
  const sourceLower = sourceField.toLowerCase();
  let bestMatch = null;
  let bestScore = 0;

  for (const targetField of targetFields) {
    const targetLower = targetField.toLowerCase();
    
    // Score baseado em correspondência exata
    if (sourceLower === targetLower) {
      return targetField;
    }
    
    // Score baseado em inclusão
    if (sourceLower.includes(targetLower) || targetLower.includes(sourceLower)) {
      const score = Math.min(sourceLower.length, targetLower.length) / Math.max(sourceLower.length, targetLower.length);
      if (score > bestScore) {
        bestScore = score;
        bestMatch = targetField;
      }
    }
  }

  return bestScore > 0.5 ? bestMatch : null;
}

function validateMapping(sourceFields, targetFields, mapping, data) {
  const errors = [];
  const warnings = [];

  // Validar campos de origem
  for (const sourceField of Object.keys(mapping)) {
    if (!sourceFields.includes(sourceField)) {
      errors.push(`Campo de origem '${sourceField}' não existe na lista de campos de origem`);
    }
  }

  // Validar campos de destino
  for (const targetField of Object.values(mapping)) {
    if (!targetFields.includes(targetField)) {
      errors.push(`Campo de destino '${targetField}' não existe na lista de campos de destino`);
    }
  }

  // Verificar campos não mapeados
  const unmappedSource = sourceFields.filter(field => !Object.keys(mapping).includes(field));
  if (unmappedSource.length > 0) {
    warnings.push(`Campos de origem não mapeados: ${unmappedSource.join(', ')}`);
  }

  const unmappedTarget = targetFields.filter(field => !Object.values(mapping).includes(field));
  if (unmappedTarget.length > 0) {
    warnings.push(`Campos de destino não mapeados: ${unmappedTarget.join(', ')}`);
  }

  // Validar dados se fornecidos
  if (data && Array.isArray(data) && data.length > 0) {
    const sampleRecord = data[0];
    for (const sourceField of Object.keys(mapping)) {
      if (!sampleRecord.hasOwnProperty(sourceField)) {
        warnings.push(`Campo de origem '${sourceField}' não encontrado nos dados de exemplo`);
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

module.exports = router;
